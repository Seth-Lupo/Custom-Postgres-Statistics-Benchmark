"""
PostgreSQL Statistics Estimator - Trial Execution Service

This module provides functionality for executing individual experiment trials.
It handles query execution, timing, plan capture, cache clearing, and 
transaction management for each trial.

Classes:
    TrialExecutor: Manages individual trial execution

Author: Generated by Assistant
Created: 2024
"""

import time
import traceback
from typing import Tuple, Dict, Any
from sqlalchemy import text
from sqlalchemy.exc import SQLAlchemyError
from sqlmodel import Session

from ..src.base import StatsSource
from ..logging_config import query_logger


class QueryExecutionError(Exception):
    """Error during query execution in a trial."""
    pass


class TrialExecutor:
    """
    Handles execution of individual experiment trials.
    
    This service manages:
    - Query execution with timing
    - Query plan capture (EXPLAIN)
    - Database cache clearing
    - Statistics counter resets
    - Transaction handling (rollback vs persist)
    - Error handling and logging
    """
    
    def __init__(self):
        """Initialize the trial executor."""
        pass
        
    def execute_trial(self, session: Session, query: str, transaction_handling: str, 
                     stats_source_instance: StatsSource) -> Tuple[float, float, Dict[str, Any]]:
        """
        Execute a single trial and return timing and plan information.
        
        Args:
            session: Database session for query execution
            query: SQL query to execute
            transaction_handling: Either 'rollback' or 'persist'
            stats_source_instance: Statistics source configuration
            
        Returns:
            Tuple containing (execution_time, cost_estimate, query_plan)
            
        Raises:
            QueryExecutionError: If trial execution fails
        """
        query_logger.debug(f"Starting trial execution with query: {query[:100]}... (transaction: {transaction_handling})")
        
        try:
            # Perform pre-trial setup
            self._prepare_trial_environment(session, stats_source_instance)
            
            # Get query plan and cost estimate
            cost_estimate, query_plan = self._get_query_plan(session, query)
            
            # Execute query with appropriate transaction handling
            execution_time = self._execute_with_transaction_handling(
                session, query, transaction_handling
            )
            
            query_logger.debug(f"Trial completed successfully: {execution_time:.4f}s, cost: {cost_estimate:.2f}")
            return execution_time, cost_estimate, query_plan
            
        except Exception as e:
            query_logger.error(f"Trial execution failed: {str(e)}")
            query_logger.debug(traceback.format_exc())
            raise QueryExecutionError(f"Trial failed: {str(e)}") from e
            
    def _prepare_trial_environment(self, session: Session, stats_source_instance: StatsSource) -> None:
        """
        Prepare the database environment for trial execution.
        
        Args:
            session: Database session
            stats_source_instance: Statistics source configuration
        """
        # Enhanced cache clearing if configured
        if stats_source_instance.settings.clear_caches:
            self._clear_database_caches(session)
            
        # Reset statistics counters if configured
        if stats_source_instance.settings.reset_counters:
            self._reset_statistics_counters(session)
            
    def _clear_database_caches(self, session: Session) -> None:
        """
        Clear database caches comprehensively.
        
        Args:
            session: Database session
        """
        query_logger.debug("Performing comprehensive cache clearing...")
        
        # Commit any pending transactions
        session.commit()
        
        # Temporarily enable autocommit for cache clearing operations
        conn = session.connection().connection
        conn.set_session(autocommit=True)
        
        try:
            # DISCARD ALL clears all temporary state
            session.execute(text("DISCARD ALL"))
        finally:
            # Restore normal transaction behavior
            conn.set_session(autocommit=False)
            
        session.commit()
        query_logger.debug("Cache clearing completed.")
        
    def _reset_statistics_counters(self, session: Session) -> None:
        """
        Reset database statistics counters.
        
        Args:
            session: Database session
        """
        query_logger.debug("Resetting statistics counters...")
        
        # Reset general statistics
        session.execute(text("SELECT pg_stat_reset()"))
        
        # Reset shared statistics (may not be available in all PostgreSQL versions)
        try:
            session.execute(text("SELECT pg_stat_reset_shared('bgwriter')"))
            session.execute(text("SELECT pg_stat_reset_shared('archiver')"))
        except Exception:
            query_logger.debug("Some shared statistics reset operations not available")
            
        # Reset pg_stat_statements if extension is available
        try:
            session.execute(text("SELECT pg_stat_statements_reset()"))
        except Exception:
            query_logger.debug("pg_stat_statements extension not available, skipping reset")
            
        session.commit()
        query_logger.debug("Statistics counters reset completed.")
        
    def _get_query_plan(self, session: Session, query: str) -> Tuple[float, Dict[str, Any]]:
        """
        Get query execution plan and cost estimate.
        
        Args:
            session: Database session
            query: SQL query to analyze
            
        Returns:
            Tuple containing (cost_estimate, query_plan)
            
        Raises:
            QueryExecutionError: If plan capture fails
        """
        query_logger.debug("Generating query plan using EXPLAIN...")
        
        try:
            explain_query = text(f"EXPLAIN (FORMAT JSON) {query}")
            explain_result = session.execute(explain_query)
            explain_result = explain_result.fetchone()
            
            if not explain_result or not explain_result[0]:
                raise QueryExecutionError("Failed to get query plan")
                
            plan_data = explain_result[0]
            query_plan = plan_data[0] if isinstance(plan_data, list) and len(plan_data) > 0 else {}
            cost_estimate = query_plan.get("Plan", {}).get("Total Cost", 0.0)
            
            query_logger.debug(f"Query plan obtained, estimated cost: {cost_estimate}")
            return cost_estimate, query_plan
            
        except Exception as e:
            query_logger.error(f"Failed to get query plan: {str(e)}")
            raise QueryExecutionError(f"Query plan capture failed: {str(e)}") from e
            
    def _execute_with_transaction_handling(self, session: Session, query: str, 
                                         transaction_handling: str) -> float:
        """
        Execute query with specified transaction handling strategy.
        
        Args:
            session: Database session
            query: SQL query to execute
            transaction_handling: Either 'rollback' or 'persist'
            
        Returns:
            Query execution time in seconds
            
        Raises:
            QueryExecutionError: If query execution fails
        """
        if transaction_handling == "rollback":
            return self._execute_with_rollback(session, query)
        else:  # transaction_handling == "persist"
            return self._execute_with_persistence(session, query)
            
    def _execute_with_rollback(self, session: Session, query: str) -> float:
        """
        Execute query with rollback transaction handling.
        
        Args:
            session: Database session
            query: SQL query to execute
            
        Returns:
            Query execution time in seconds
        """
        query_logger.debug("Executing query with rollback transaction handling...")
        
        # Create a savepoint to rollback to after query execution
        savepoint = session.begin_nested()
        
        try:
            # Execute query and measure time
            start_time = time.perf_counter()
            session.execute(text(query))
            session.flush()  # Ensure query is executed but don't commit
            end_time = time.perf_counter()
            
            execution_time = end_time - start_time
            query_logger.debug(f"Query executed in {execution_time:.4f} seconds")
            
            # Rollback to savepoint to undo any changes
            savepoint.rollback()
            query_logger.debug("Rolled back transaction - database state preserved")
            
            return execution_time
            
        except Exception as e:
            savepoint.rollback()
            raise e
            
    def _execute_with_persistence(self, session: Session, query: str) -> float:
        """
        Execute query with persistent transaction handling.
        
        Args:
            session: Database session
            query: SQL query to execute
            
        Returns:
            Query execution time in seconds
        """
        query_logger.debug("Executing query with persistent transaction handling...")
        
        # Execute query and commit changes
        start_time = time.perf_counter()
        session.execute(text(query))
        session.commit()  # Commit transaction to persist changes
        end_time = time.perf_counter()
        
        execution_time = end_time - start_time
        query_logger.debug(f"Query executed in {execution_time:.4f} seconds (changes persisted)")
        
        return execution_time 