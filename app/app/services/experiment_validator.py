"""
PostgreSQL Statistics Estimator - Experiment Validation Service

This module provides functionality for validating experiment inputs, 
configurations, and parameters before experiment execution begins.
It ensures data integrity and prevents common configuration errors.

Classes:
    ExperimentValidator: Validates experiment inputs and configurations

Author: Generated by Assistant
Created: 2024
"""

import os
import yaml
from typing import Dict, List, Optional, Tuple
from pathlib import Path

from ..src.base import StatsSource, StatsSourceConfig
from ..logging_config import experiment_logger


class ValidationError(Exception):
    """Error during experiment validation."""
    pass


class ExperimentValidator:
    """
    Handles validation of experiment inputs and configurations.
    
    This service validates:
    - Statistics source availability and configuration
    - File paths and accessibility  
    - Parameter ranges and values
    - YAML configuration syntax and content
    - Database connection requirements
    """
    
    def __init__(self, available_sources: Dict[str, type]):
        """
        Initialize the experiment validator.
        
        Args:
            available_sources: Dictionary mapping source keys to source classes
        """
        self.available_sources = available_sources
        
    def validate_experiment_parameters(self, stats_source: str, config_name: Optional[str], 
                                     config_yaml: Optional[str], query: str, iterations: int,
                                     stats_reset_strategy: str, transaction_handling: str,
                                     dump_path: str, name: str) -> None:
        """
        Validate all experiment parameters before execution.
        
        Args:
            stats_source: Statistics source identifier
            config_name: Named configuration (optional)
            config_yaml: Custom YAML configuration (optional)
            query: SQL query to execute
            iterations: Number of trial iterations
            stats_reset_strategy: Statistics reset strategy
            transaction_handling: Transaction handling mode
            dump_path: Path to database dump file
            name: Experiment name
            
        Raises:
            ValidationError: If any validation fails
        """
        experiment_logger.info("Validating experiment parameters...")
        
        # Validate basic parameters
        self._validate_basic_parameters(name, iterations, query)
        
        # Validate statistics source and configuration
        self._validate_stats_source_config(stats_source, config_name, config_yaml)
        
        # Validate strategy parameters
        self._validate_strategies(stats_reset_strategy, transaction_handling)
        
        # Validate file paths
        self._validate_file_paths(dump_path)
        
        experiment_logger.info("All experiment parameters validated successfully")
        
    def _validate_basic_parameters(self, name: str, iterations: int, query: str) -> None:
        """
        Validate basic experiment parameters.
        
        Args:
            name: Experiment name
            iterations: Number of iterations
            query: SQL query
            
        Raises:
            ValidationError: If validation fails
        """
        # Validate experiment name
        if not name or not name.strip():
            raise ValidationError("Experiment name cannot be empty")
            
        if len(name.strip()) > 255:
            raise ValidationError("Experiment name cannot exceed 255 characters")
            
        # Validate iterations
        if not isinstance(iterations, int) or iterations < 1:
            raise ValidationError("Iterations must be a positive integer")
            
        if iterations > 10000:
            raise ValidationError("Iterations cannot exceed 10,000 for performance reasons")
            
        # Validate query
        if not query or not query.strip():
            raise ValidationError("SQL query cannot be empty")
            
        # Basic SQL injection prevention (simple check)
        dangerous_keywords = ['DROP', 'DELETE', 'TRUNCATE', 'ALTER', 'CREATE USER', 'GRANT']
        query_upper = query.upper()
        for keyword in dangerous_keywords:
            if keyword in query_upper:
                experiment_logger.warning(f"Potentially dangerous SQL keyword detected: {keyword}")
                
    def _validate_stats_source_config(self, stats_source: str, config_name: Optional[str], 
                                    config_yaml: Optional[str]) -> None:
        """
        Validate statistics source and configuration.
        
        Args:
            stats_source: Statistics source identifier
            config_name: Named configuration
            config_yaml: Custom YAML configuration
            
        Raises:
            ValidationError: If validation fails
        """
        # Validate stats source exists
        if stats_source not in self.available_sources:
            raise ValidationError(f"Unknown statistics source: {stats_source}")
            
        source_class = self.available_sources[stats_source]
        
        # If custom YAML is provided, validate it
        if config_yaml:
            self._validate_yaml_configuration(config_yaml, source_class)
        elif config_name:
            # Validate named configuration exists
            self._validate_named_configuration(config_name, source_class)
            
    def _validate_yaml_configuration(self, config_yaml: str, source_class: type) -> None:
        """
        Validate custom YAML configuration.
        
        Args:
            config_yaml: YAML configuration string
            source_class: Statistics source class
            
        Raises:
            ValidationError: If YAML validation fails
        """
        try:
            # Parse YAML syntax
            config_data = yaml.safe_load(config_yaml)
            
            if not isinstance(config_data, dict):
                raise ValidationError("Configuration must be a YAML dictionary")
                
            # Validate required sections
            if 'name' not in config_data:
                raise ValidationError("Configuration must include 'name' field")
                
            if 'settings' not in config_data:
                raise ValidationError("Configuration must include 'settings' section")
                
            # Attempt to create configuration object
            config = StatsSourceConfig(config_data)
            
            # Test instantiation with the configuration
            source_class(config)
            
            experiment_logger.debug("Custom YAML configuration validated successfully")
            
        except yaml.YAMLError as e:
            raise ValidationError(f"Invalid YAML syntax: {str(e)}")
        except Exception as e:
            raise ValidationError(f"Configuration validation failed: {str(e)}")
            
    def _validate_named_configuration(self, config_name: str, source_class: type) -> None:
        """
        Validate named configuration exists and is accessible.
        
        Args:
            config_name: Name of the configuration
            source_class: Statistics source class
            
        Raises:
            ValidationError: If named configuration is invalid
        """
        try:
            instance = source_class()
            available_configs = instance.get_available_configs()
            
            # Check if the named config exists
            config_names = [name for name, _ in available_configs]
            if config_name not in config_names:
                raise ValidationError(f"Configuration '{config_name}' not found for {source_class.__name__}")
                
            # Try to load the configuration
            instance.load_config(config_name)
            
            experiment_logger.debug(f"Named configuration '{config_name}' validated successfully")
            
        except Exception as e:
            raise ValidationError(f"Failed to validate named configuration '{config_name}': {str(e)}")
            
    def _validate_strategies(self, stats_reset_strategy: str, transaction_handling: str) -> None:
        """
        Validate strategy parameters.
        
        Args:
            stats_reset_strategy: Statistics reset strategy
            transaction_handling: Transaction handling mode
            
        Raises:
            ValidationError: If strategies are invalid
        """
        # Validate stats reset strategy
        valid_reset_strategies = ['once', 'per_trial']
        if stats_reset_strategy not in valid_reset_strategies:
            raise ValidationError(f"Invalid stats reset strategy. Must be one of: {valid_reset_strategies}")
            
        # Validate transaction handling
        valid_transaction_modes = ['rollback', 'persist']
        if transaction_handling not in valid_transaction_modes:
            raise ValidationError(f"Invalid transaction handling. Must be one of: {valid_transaction_modes}")
            
    def _validate_file_paths(self, dump_path: str) -> None:
        """
        Validate file paths exist and are accessible.
        
        Args:
            dump_path: Path to database dump file
            
        Raises:
            ValidationError: If file validation fails
        """
        # Validate dump file exists
        if not os.path.exists(dump_path):
            raise ValidationError(f"Database dump file not found: {dump_path}")
            
        if not os.path.isfile(dump_path):
            raise ValidationError(f"Database dump path is not a file: {dump_path}")
            
        if not os.access(dump_path, os.R_OK):
            raise ValidationError(f"Database dump file is not readable: {dump_path}")
            
        # Validate file size (warn if very large)
        file_size = os.path.getsize(dump_path)
        if file_size > 1024 * 1024 * 1024:  # 1GB
            experiment_logger.warning(f"Large dump file detected ({file_size / 1024 / 1024 / 1024:.1f}GB). This may take time to load.")
            
    def validate_configuration_modification(self, original_yaml: str, modified_yaml: str) -> Tuple[bool, Optional[str]]:
        """
        Validate if a configuration has been meaningfully modified.
        
        Args:
            original_yaml: Original configuration YAML
            modified_yaml: Modified configuration YAML
            
        Returns:
            Tuple of (is_modified, error_message)
        """
        try:
            # Normalize whitespace and compare
            original_normalized = original_yaml.strip()
            modified_normalized = modified_yaml.strip()
            
            is_modified = original_normalized != modified_normalized
            
            if is_modified:
                # Validate the modified configuration is still valid
                try:
                    config_data = yaml.safe_load(modified_yaml)
                    StatsSourceConfig(config_data)
                except Exception as e:
                    return False, f"Modified configuration is invalid: {str(e)}"
                    
            return is_modified, None
            
        except Exception as e:
            return False, f"Configuration comparison failed: {str(e)}" 