/**
 * PostgreSQL Statistics Estimator - Experiment Form JavaScript
 * 
 * This module handles all JavaScript functionality for the experiment 
 * configuration form, including dynamic configuration loading, YAML editing,
 * form validation, and real-time experiment progress tracking via SSE.
 * 
 * Dependencies: Bootstrap 5, HTMX
 * 
 * Author: Generated by Assistant
 * Created: 2024
 */

// Global variables for experiment form functionality
let currentLogLevel = 'info';
let logHistory = [];
let streamClosed = false;
let originalYamlConfig = '';
let currentStatsSource = '';
let currentExperimentId = null;
let eventSource = null;

/**
 * Initialize experiment form functionality when DOM is loaded
 */
document.addEventListener('DOMContentLoaded', function() {
    initializeFormValidation();
    initializeConfigurationHandlers();
    checkInitialConfigState();
    setupHTMXEventHandlers();
});

/**
 * Set up HTMX event handlers for experiment progress
 */
function setupHTMXEventHandlers() {
    console.log('Setting up HTMX event handlers...');
    
    // Listen for HTMX after swap events to initialize SSE connections
    document.body.addEventListener('htmx:afterSwap', function(event) {
        console.log('HTMX after swap event received:', event);
        
        // Check if the swapped content contains experiment progress
        const experimentResult = event.detail.target.querySelector('#experiment-result');
        if (experimentResult) {
            console.log('Found experiment result in swapped content');
            // Extract experiment ID from progress bar ID
            const progressBar = experimentResult.querySelector('[id^="progress-bar-"]');
            if (progressBar) {
                const experimentId = progressBar.id.replace('progress-bar-', '');
                currentExperimentId = parseInt(experimentId);
                console.log('Starting SSE connection for experiment:', currentExperimentId);
                initializeExperimentProgress(currentExperimentId);
                
                // Start pure JavaScript EventSource connection
                startEventSourceConnection(currentExperimentId);
            } else {
                console.log('No progress bar found in experiment result');
            }
        } else {
            console.log('No experiment result found in swapped content');
        }
    });
    
    console.log('HTMX event handlers setup complete');
}

/**
 * Start EventSource connection for real-time experiment updates
 * @param {number} experimentId - The experiment ID to track
 */
function startEventSourceConnection(experimentId) {
    // Close any existing connection
    if (eventSource) {
        eventSource.close();
    }
    
    const url = `/experiment/stream/${experimentId}`;
    console.log('Opening EventSource connection to:', url);
    
    eventSource = new EventSource(url);
    
    eventSource.onopen = function(event) {
        console.log('EventSource connection opened:', event);
        addLogMessage('ðŸ”— Real-time connection established', 'info');
    };
    
    eventSource.onmessage = function(event) {
        console.log('EventSource message received:', event.data);
        try {
            const data = JSON.parse(event.data);
            console.log('Parsed EventSource data:', data);
            handleSSEMessage(data);
        } catch (error) {
            console.error('Error parsing EventSource message:', error, 'Raw data:', event.data);
        }
    };
    
    eventSource.onerror = function(event) {
        console.error('EventSource error:', event);
        if (eventSource.readyState === EventSource.CLOSED) {
            console.log('EventSource connection closed');
            addLogMessage('ðŸ”Œ Connection closed', 'info');
        } else {
            console.error('EventSource connection error');
            addLogMessage('âŒ Connection error', 'error');
        }
    };
}

/**
 * Initialize experiment progress tracking for a specific experiment
 * @param {number} experimentId - The experiment ID to track
 */
function initializeExperimentProgress(experimentId) {
    currentExperimentId = experimentId;
    logHistory = [];
    streamClosed = false;
    
    // Initialize progress display
    updateProgressBar(0, 0);
    clearProgressLog();
    
    // Add initial status message
    addLogMessage('â³ Initializing experiment...', 'info');
    
    console.log(`Initialized progress tracking for experiment ${experimentId}`);
}

/**
 * Handle incoming SSE messages
 * @param {Object} data - Parsed SSE message data
 */
function handleSSEMessage(data) {
    console.log('Received SSE message:', data);
    
    if (data.status === 'running') {
        handleRunningStatus(data);
    } else if (data.status === 'completed') {
        handleCompletedStatus(data);
    } else if (data.status === 'error') {
        handleErrorStatus(data);
    } else if (data.html) {
        // Handle direct HTML updates
        updateExperimentContainer(data.html);
    }
}

/**
 * Handle running status updates
 * @param {Object} data - SSE message data
 */
function handleRunningStatus(data) {
    // Update progress bar
    if (data.progress !== undefined) {
        updateProgressBar(data.progress, 100);
    }
    
    // Add new messages to log
    if (data.messages && Array.isArray(data.messages)) {
        data.messages.forEach(message => {
            addLogMessage(message, data.log_level || 'info');
        });
    }
}

/**
 * Handle completed status
 * @param {Object} data - SSE message data
 */
function handleCompletedStatus(data) {
    streamClosed = true;
    
    // Update progress to 100%
    updateProgressBar(100, 100);
    
    // Add completion message
    addLogMessage('âœ… Experiment completed successfully!', 'info');
    
    // Close EventSource connection
    if (eventSource) {
        eventSource.close();
        eventSource = null;
        console.log('EventSource connection closed after completion');
    }
    
    // Show completion HTML if provided
    if (data.html) {
        const experimentContainer = document.getElementById('experiment-container');
        if (experimentContainer) {
            // Append the completion message after the existing content
            const completionDiv = document.createElement('div');
            completionDiv.innerHTML = data.html;
            experimentContainer.appendChild(completionDiv);
        }
    }
    
    console.log('Experiment completed successfully');
}

/**
 * Handle error status
 * @param {Object} data - SSE message data
 */
function handleErrorStatus(data) {
    streamClosed = true;
    
    // Add error message to log
    const errorMessage = data.error || 'Unknown error occurred';
    addLogMessage(`âŒ Error: ${errorMessage}`, 'error');
    
    // Close EventSource connection
    if (eventSource) {
        eventSource.close();
        eventSource = null;
        console.log('EventSource connection closed after error');
    }
    
    // Show error HTML if provided
    if (data.html) {
        const experimentContainer = document.getElementById('experiment-container');
        if (experimentContainer) {
            const errorDiv = document.createElement('div');
            errorDiv.innerHTML = data.html;
            experimentContainer.appendChild(errorDiv);
        }
    }
    
    console.error('Experiment failed:', errorMessage);
}

/**
 * Update progress bar with current progress
 * @param {number} current - Current progress value
 * @param {number} total - Total progress value
 */
function updateProgressBar(current, total) {
    if (!currentExperimentId) return;
    
    const progressBar = document.getElementById(`progress-bar-${currentExperimentId}`);
    if (!progressBar) return;
    
    const percentage = total > 0 ? Math.round((current / total) * 100) : 0;
    
    progressBar.style.width = `${percentage}%`;
    progressBar.setAttribute('aria-valuenow', percentage.toString());
    progressBar.textContent = `${percentage}%`;
    
    // Update progress bar color based on status
    if (percentage === 100 && streamClosed) {
        progressBar.classList.remove('bg-primary');
        progressBar.classList.add('bg-success');
    }
}

/**
 * Add a message to the progress log
 * @param {string} message - Log message to add
 * @param {string} level - Log level (info, warning, error)
 */
function addLogMessage(message, level = 'info') {
    if (!currentExperimentId) return;
    
    const logElement = document.getElementById(`progress-log-${currentExperimentId}`);
    if (!logElement) return;
    
    // Store message in history
    logHistory.push({ message, level, timestamp: new Date() });
    
    // Apply current log level filter
    if (shouldShowLogLevel(level)) {
        // Add message to display
        const messageElement = document.createElement('div');
        messageElement.className = `log-message log-${level}`;
        messageElement.textContent = message;
        
        logElement.appendChild(messageElement);
        
        // Auto-scroll to bottom
        logElement.scrollTop = logElement.scrollHeight;
    }
}

/**
 * Check if a log level should be shown based on current filter
 * @param {string} level - Log level to check
 * @returns {boolean} - Whether the level should be shown
 */
function shouldShowLogLevel(level) {
    switch (currentLogLevel) {
        case 'error':
            return level === 'error';
        case 'warning':
            return level === 'warning' || level === 'error';
        case 'info':
        default:
            return true; // Show all levels
    }
}

/**
 * Clear the progress log display
 */
function clearProgressLog() {
    if (!currentExperimentId) return;
    
    const logElement = document.getElementById(`progress-log-${currentExperimentId}`);
    if (logElement) {
        logElement.innerHTML = '';
    }
}

/**
 * Update experiment container with new HTML content
 * @param {string} html - HTML content to update
 */
function updateExperimentContainer(html) {
    const experimentContainer = document.getElementById('experiment-container');
    if (experimentContainer) {
        experimentContainer.innerHTML = html;
    }
}

/**
 * Set log level filter for progress display
 * @param {string} level - Log level to filter by
 * @param {HTMLElement} button - Button element that was clicked
 */
function setLogLevel(level, button) {
    currentLogLevel = level;

    // Update button states
    button.parentElement.querySelectorAll('button').forEach(btn => {
        btn.classList.remove('active', 'btn-secondary');
        btn.classList.add('btn-outline-secondary');
    });
    button.classList.remove('btn-outline-secondary');
    button.classList.add('active', 'btn-secondary');

    // Re-render log messages with new filter
    filterLogMessages();
}

/**
 * Filter log messages based on current log level
 */
function filterLogMessages() {
    if (!currentExperimentId) return;
    
    const logElement = document.getElementById(`progress-log-${currentExperimentId}`);
    if (!logElement) return;
    
    // Clear current display
    logElement.innerHTML = '';
    
    // Re-add messages that match current filter
    logHistory.forEach(({ message, level }) => {
        if (shouldShowLogLevel(level)) {
            const messageElement = document.createElement('div');
            messageElement.className = `log-message log-${level}`;
            messageElement.textContent = message;
            logElement.appendChild(messageElement);
        }
    });
    
    // Auto-scroll to bottom
    logElement.scrollTop = logElement.scrollHeight;
    
    console.log(`Log level set to: ${currentLogLevel}`);
}

/**
 * Initialize Bootstrap form validation
 */
function initializeFormValidation() {
    const forms = document.querySelectorAll('.needs-validation');
    Array.from(forms).forEach(form => {
        form.addEventListener('submit', event => {
            if (!form.checkValidity()) {
                event.preventDefault();
                event.stopPropagation();
            }
            form.classList.add('was-validated');
        }, false);
    });
}

/**
 * Initialize configuration-related event handlers
 */
function initializeConfigurationHandlers() {
    const configSelect = document.getElementById('config_name');
    if (configSelect) {
        configSelect.addEventListener('change', function () {
            if (this.value && currentStatsSource) {
                loadConfigurationYaml(currentStatsSource, this.value);
            }
        });
    }
}

/**
 * Check initial configuration state on page load
 */
function checkInitialConfigState() {
    const editButton = document.getElementById('edit-config-btn');
    const customYaml = document.getElementById('config_yaml');
    
    if (editButton && customYaml && customYaml.value && customYaml.value.trim()) {
        editButton.innerHTML = '<i class="bi bi-pencil-square me-1"></i> Customized';
        editButton.classList.remove('btn-outline-secondary');
        editButton.classList.add('btn-outline-warning');
    }
}

/**
 * Load available configurations for a selected statistics source
 * @param {string} statsSource - The selected statistics source identifier
 */
function loadConfigurations(statsSource) {
    const configSelect = document.getElementById('config_name');
    const editButton = document.getElementById('edit-config-btn');

    if (!statsSource) {
        resetConfigurationControls(configSelect, editButton);
        return;
    }

    currentStatsSource = statsSource;
    showConfigurationLoading(configSelect, editButton);

    // Fetch configurations for the selected stats source
    fetch(`/experiment/configs/${statsSource}`)
        .then(response => response.json())
        .then(data => {
            if (data.error) {
                handleConfigurationError(configSelect, data.error);
                return;
            }

            if (!data.configs || data.configs.length === 0) {
                showNoConfigurationsAvailable(configSelect);
                return;
            }

            populateConfigurationOptions(configSelect, data.configs);
            enableConfigurationControls(configSelect, editButton);
            loadDefaultConfiguration(configSelect);
        })
        .catch(error => {
            console.error('Error fetching configurations:', error);
            handleConfigurationError(configSelect, 'Error loading configurations');
        });
}

/**
 * Reset configuration controls to initial state
 */
function resetConfigurationControls(configSelect, editButton) {
    configSelect.disabled = true;
    editButton.disabled = true;
    configSelect.innerHTML = '<option value="" disabled selected>Select a statistics source first</option>';
}

/**
 * Show loading state for configuration controls
 */
function showConfigurationLoading(configSelect, editButton) {
    configSelect.disabled = true;
    editButton.disabled = true;
    configSelect.innerHTML = '<option value="" disabled selected>Loading configurations...</option>';
}

/**
 * Handle configuration loading errors
 */
function handleConfigurationError(configSelect, errorMessage) {
    configSelect.innerHTML = '<option value="" disabled selected>Error loading configurations</option>';
    console.error('Configuration loading error:', errorMessage);
}

/**
 * Show message when no configurations are available
 */
function showNoConfigurationsAvailable(configSelect) {
    configSelect.innerHTML = '<option value="" disabled selected>No configurations available</option>';
}

/**
 * Populate configuration select with available options
 */
function populateConfigurationOptions(configSelect, configs) {
    configSelect.innerHTML = '<option value="" disabled selected>Select a configuration</option>';
    
    configs.forEach(([key, description]) => {
        const option = document.createElement('option');
        option.value = key;
        option.textContent = description;
        if (key === 'default') {
            option.selected = true;
        }
        configSelect.appendChild(option);
    });
}

/**
 * Enable configuration controls after successful loading
 */
function enableConfigurationControls(configSelect, editButton) {
    configSelect.disabled = false;
    editButton.disabled = false;
}

/**
 * Load default configuration if available
 */
function loadDefaultConfiguration(configSelect) {
    if (configSelect.value || configSelect.querySelector('option[value="default"]')) {
        const selectedConfig = configSelect.value || 'default';
        loadConfigurationYaml(currentStatsSource, selectedConfig);
    }
}

/**
 * Load YAML configuration content for editing
 * @param {string} statsSource - Statistics source identifier
 * @param {string} configName - Configuration name
 */
function loadConfigurationYaml(statsSource, configName) {
    fetch(`/experiment/configs/${statsSource}/${configName}/yaml`)
        .then(response => response.json())
        .then(data => {
            if (data.error) {
                console.error('Error loading YAML:', data.error);
                return;
            }
            
            originalYamlConfig = data.yaml;
            // Clear any custom YAML since we're loading a predefined config
            document.getElementById('config_yaml').value = '';

            // Reset edit button state
            resetEditButtonState();
        })
        .catch(error => {
            console.error('Error fetching YAML:', error);
        });
}

/**
 * Reset edit button to default state
 */
function resetEditButtonState() {
    const editButton = document.getElementById('edit-config-btn');
    editButton.innerHTML = '<i class="bi bi-pencil-square me-1"></i> Edit';
    editButton.classList.remove('btn-outline-success', 'btn-outline-warning');
    editButton.classList.add('btn-outline-secondary');
}

/**
 * Open the configuration editor modal
 */
function openConfigEditor() {
    const configSelect = document.getElementById('config_name');
    const selectedConfig = configSelect.value;

    if (!selectedConfig || !currentStatsSource) {
        alert('Please select a configuration first.');
        return;
    }

    // Update modal info
    updateModalInfo(selectedConfig);
    
    // Load appropriate YAML content
    loadYamlIntoEditor();
    
    // Show the modal
    const modal = new bootstrap.Modal(document.getElementById('configEditorModal'));
    modal.show();
}

/**
 * Update configuration modal information
 */
function updateModalInfo(selectedConfig) {
    document.getElementById('config-source-name').textContent = currentStatsSource;
    document.getElementById('config-original-name').textContent = selectedConfig;
}

/**
 * Load YAML content into the editor
 */
function loadYamlIntoEditor() {
    const customYaml = document.getElementById('config_yaml').value;
    
    if (customYaml && customYaml.trim()) {
        // Load the previously edited YAML
        document.getElementById('yaml-editor').value = customYaml;
        updateConfigStatus('Modified', 'badge bg-warning');
    } else {
        // Load the original YAML
        document.getElementById('yaml-editor').value = originalYamlConfig;
        updateConfigStatus('Unchanged', 'badge bg-secondary');
    }
}

/**
 * Update configuration status display
 */
function updateConfigStatus(statusText, statusClass) {
    const statusElement = document.getElementById('config-status');
    statusElement.textContent = statusText;
    statusElement.className = statusClass;
}

/**
 * Reset configuration to original state
 */
function resetConfiguration() {
    document.getElementById('yaml-editor').value = originalYamlConfig;
    updateConfigStatus('Unchanged', 'badge bg-secondary');

    // Clear the hidden config_yaml field
    document.getElementById('config_yaml').value = '';
    resetEditButtonState();
}

/**
 * Save configuration changes
 */
function saveConfiguration() {
    const yamlContent = document.getElementById('yaml-editor').value.trim();

    if (!yamlContent) {
        alert('Configuration cannot be empty.');
        return;
    }

    // Basic YAML validation
    if (!validateYamlConfiguration(yamlContent)) {
        return;
    }

    // Check if configuration was actually modified
    const isActuallyModified = yamlContent.trim() !== originalYamlConfig.trim();

    // Store the edited YAML
    document.getElementById('config_yaml').value = yamlContent;

    // Update UI based on modification status
    updateConfigurationUI(isActuallyModified);

    // Close the modal
    const modal = bootstrap.Modal.getInstance(document.getElementById('configEditorModal'));
    modal.hide();
}

/**
 * Validate YAML configuration content
 */
function validateYamlConfiguration(yamlContent) {
    try {
        // Basic validation - check for required sections
        if (!yamlContent.includes('name:') || !yamlContent.includes('settings:')) {
            throw new Error('Configuration must include name and settings sections');
        }
        return true;
    } catch (error) {
        alert('Invalid YAML configuration: ' + error.message);
        return false;
    }
}

/**
 * Update configuration UI based on modification status
 */
function updateConfigurationUI(isModified) {
    const editButton = document.getElementById('edit-config-btn');
    
    if (isModified) {
        updateConfigStatus('Modified', 'badge bg-warning');
        editButton.innerHTML = '<i class="bi bi-pencil-square me-1"></i> Customized';
        editButton.classList.remove('btn-outline-secondary');
        editButton.classList.add('btn-outline-warning');
    } else {
        updateConfigStatus('Unchanged', 'badge bg-secondary');
        document.getElementById('config_yaml').value = '';
        resetEditButtonState();
    }
}

/**
 * Clean up EventSource connection
 */
function cleanupEventSource() {
    if (eventSource) {
        eventSource.close();
        eventSource = null;
        console.log('EventSource connection cleaned up');
    }
}

/**
 * Handle page unload to clean up connections
 */
window.addEventListener('beforeunload', function() {
    cleanupEventSource();
}); 