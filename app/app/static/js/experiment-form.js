/**
 * PostgreSQL Statistics Estimator - Experiment Form JavaScript
 * 
 * This module handles all JavaScript functionality for the experiment 
 * configuration form, including dynamic configuration loading, YAML editing,
 * form validation, and real-time experiment progress tracking via SSE.
 * 
 * Dependencies: Bootstrap 5, HTMX
 * 
 * Author: Generated by Assistant
 * Created: 2024
 */

// Global variables for experiment tracking
let currentExperimentId = null;
let eventSource = null;
let logHistory = [];
let currentLogLevel = 'info';
let streamClosed = false;
let currentStatsSource = null;
let originalSettingsYaml = '';
let originalConfigYaml = '';

/**
 * Initialize everything when DOM is loaded
 */
document.addEventListener('DOMContentLoaded', function() {
    setupHTMXEventHandlers();
    initializeFormValidation();
    initializeConfigurationHandlers();
    checkInitialConfigState();
});

/**
 * Setup HTMX event handlers for experiment tracking
 */
function setupHTMXEventHandlers() {
    // After successful submission
    document.body.addEventListener('htmx:afterRequest', function(event) {
        if (event.detail.xhr.status === 200 && event.detail.target.id === 'experiment-container') {
            const response = JSON.parse(event.detail.xhr.responseText);
            if (response.experiment_id) {
                currentExperimentId = response.experiment_id;
                initializeExperimentProgress(currentExperimentId);
            }
        }
    });

    // Before form submission
    document.body.addEventListener('htmx:beforeRequest', function(event) {
        if (event.detail.target.id === 'experiment-form') {
            // Clear any previous experiment state
            currentExperimentId = null;
            logHistory = [];
            streamClosed = false;
            
            // Close any existing event source
            cleanupEventSource();
        }
    });

    // On error
    document.body.addEventListener('htmx:responseError', function(event) {
        console.error('HTMX Request Error:', event.detail);
        if (event.detail.target.id === 'experiment-container') {
            const errorContainer = document.getElementById('experiment-container');
            if (errorContainer) {
                errorContainer.innerHTML = `
                    <div class="alert alert-danger" role="alert">
                        <i class="bi bi-exclamation-triangle me-2"></i>
                        <strong>Error:</strong> Failed to start experiment. Please check your inputs and try again.
                    </div>
                `;
            }
        }
    });

    // Clean up on unload
    window.addEventListener('beforeunload', cleanupEventSource);
}

/**
 * Start EventSource connection for real-time updates
 * @param {string} experimentId - The experiment ID to track
 */
function startEventSourceConnection(experimentId) {
    const eventSourceUrl = `/experiment/stream/${experimentId}`;
    console.log(`Starting EventSource connection to: ${eventSourceUrl}`);
    
    eventSource = new EventSource(eventSourceUrl);
    
    eventSource.onopen = function() {
        console.log('EventSource connection opened');
    };
    
    eventSource.onmessage = function(event) {
        try {
            const data = JSON.parse(event.data);
            console.log('SSE Message received:', data);
            handleSSEMessage(data);
        } catch (error) {
            console.error('Error parsing SSE message:', error);
        }
    };
    
    eventSource.onerror = function(error) {
        console.error('EventSource error:', error);
        
        // Check if connection is closed
        if (eventSource.readyState === EventSource.CLOSED) {
            console.log('EventSource connection closed by server');
            streamClosed = true;
        }
    };
}

/**
 * Initialize experiment progress tracking
 * @param {string} experimentId - The experiment ID to track
 */
function initializeExperimentProgress(experimentId) {
    console.log(`Initializing progress tracking for experiment: ${experimentId}`);
    
    // Start EventSource connection
    startEventSourceConnection(experimentId);
    
    // Initialize log level filter buttons if they exist
    const logLevelButtons = document.querySelectorAll('[onclick^="setLogLevel"]');
    if (logLevelButtons.length > 0) {
        // Set default to info level
        const infoButton = Array.from(logLevelButtons).find(btn => btn.textContent.trim() === 'Info');
        if (infoButton) {
            setLogLevel('info', infoButton);
        }
    }
}

/**
 * Handle SSE (Server-Sent Events) messages
 * @param {Object} data - The parsed SSE data
 */
function handleSSEMessage(data) {
    console.log('Processing SSE message:', data);
    
    switch (data.status) {
        case 'running':
            handleRunningStatus(data);
            break;
        case 'completed':
            handleCompletedStatus(data);
            break;
        case 'error':
            handleErrorStatus(data);
            break;
        default:
            console.warn('Unknown status in SSE message:', data.status);
    }
}

/**
 * Handle running status updates
 * @param {Object} data - The SSE data for running status
 */
function handleRunningStatus(data) {
    // Update progress bar if progress info is available
    if (data.current !== undefined && data.total !== undefined) {
        updateProgressBar(data.current, data.total);
    }
    
    // Add log message if available
    if (data.message) {
        const level = data.level || 'info';
        addLogMessage(data.message, level);
    }
}

/**
 * Handle completed status
 * @param {Object} data - The SSE data for completed status
 */
function handleCompletedStatus(data) {
    console.log('Experiment completed successfully');
    
    // Close EventSource connection
    if (eventSource) {
        eventSource.close();
        eventSource = null;
        streamClosed = true;
        console.log('EventSource connection closed after completion');
    }
    
    // Update progress to 100%
    updateProgressBar(100, 100);
    
    // Add completion message
    addLogMessage('✅ Experiment completed successfully!', 'info');
    
    // Update experiment container with final HTML if provided
    if (data.html) {
        updateExperimentContainer(data.html);
    }
}

/**
 * Handle error status
 * @param {Object} data - The SSE data for error status
 */
function handleErrorStatus(data) {
    const errorMessage = data.message || 'Unknown error occurred';
    console.error('Experiment error:', errorMessage);
    
    // Add error message to log
    addLogMessage(`❌ Error: ${errorMessage}`, 'error');
    
    // Close EventSource connection
    if (eventSource) {
        eventSource.close();
        eventSource = null;
        console.log('EventSource connection closed after error');
    }
    
    // Show error HTML if provided
    if (data.html) {
        const experimentContainer = document.getElementById('experiment-container');
        if (experimentContainer) {
            const errorDiv = document.createElement('div');
            errorDiv.innerHTML = data.html;
            experimentContainer.appendChild(errorDiv);
        }
    }
    
    console.error('Experiment failed:', errorMessage);
}

/**
 * Update progress bar with current progress
 * @param {number} current - Current progress value
 * @param {number} total - Total progress value
 */
function updateProgressBar(current, total) {
    if (!currentExperimentId) return;
    
    const progressBar = document.getElementById(`progress-bar-${currentExperimentId}`);
    if (!progressBar) return;
    
    const percentage = total > 0 ? Math.round((current / total) * 100) : 0;
    
    progressBar.style.width = `${percentage}%`;
    progressBar.setAttribute('aria-valuenow', percentage.toString());
    progressBar.textContent = `${percentage}%`;
    
    // Update progress bar color based on status
    if (percentage === 100 && streamClosed) {
        progressBar.classList.remove('bg-primary');
        progressBar.classList.add('bg-success');
    }
}

/**
 * Add a message to the progress log
 * @param {string} message - Log message to add
 * @param {string} level - Log level (info, warning, error)
 */
function addLogMessage(message, level = 'info') {
    if (!currentExperimentId) return;
    
    const logElement = document.getElementById(`progress-log-${currentExperimentId}`);
    if (!logElement) return;
    
    // Store message in history
    logHistory.push({ message, level, timestamp: new Date() });
    
    // Apply current log level filter
    if (shouldShowLogLevel(level)) {
        // Add message to display
        const messageElement = document.createElement('div');
        messageElement.className = `log-message log-${level}`;
        messageElement.textContent = message;
        
        logElement.appendChild(messageElement);
        
        // Auto-scroll to bottom
        logElement.scrollTop = logElement.scrollHeight;
    }
}

/**
 * Check if a log level should be shown based on current filter
 * @param {string} level - Log level to check
 * @returns {boolean} - Whether the level should be shown
 */
function shouldShowLogLevel(level) {
    switch (currentLogLevel) {
        case 'error':
            return level === 'error';
        case 'warning':
            return level === 'warning' || level === 'error';
        case 'info':
        default:
            return true; // Show all levels
    }
}

/**
 * Clear the progress log display
 */
function clearProgressLog() {
    if (!currentExperimentId) return;
    
    const logElement = document.getElementById(`progress-log-${currentExperimentId}`);
    if (logElement) {
        logElement.innerHTML = '';
    }
}

/**
 * Update experiment container with new HTML content
 * @param {string} html - HTML content to update
 */
function updateExperimentContainer(html) {
    const experimentContainer = document.getElementById('experiment-container');
    if (experimentContainer) {
        experimentContainer.innerHTML = html;
    }
}

/**
 * Set log level filter for progress display
 * @param {string} level - Log level to filter by
 * @param {HTMLElement} button - Button element that was clicked
 */
function setLogLevel(level, button) {
    currentLogLevel = level;

    // Update button states
    button.parentElement.querySelectorAll('button').forEach(btn => {
        btn.classList.remove('active', 'btn-secondary');
        btn.classList.add('btn-outline-secondary');
    });
    button.classList.remove('btn-outline-secondary');
    button.classList.add('active', 'btn-secondary');

    // Re-render log messages with new filter
    filterLogMessages();
}

/**
 * Filter log messages based on current log level
 */
function filterLogMessages() {
    if (!currentExperimentId) return;
    
    const logElement = document.getElementById(`progress-log-${currentExperimentId}`);
    if (!logElement) return;
    
    // Clear current display
    logElement.innerHTML = '';
    
    // Re-add messages that match current filter
    logHistory.forEach(({ message, level }) => {
        if (shouldShowLogLevel(level)) {
            const messageElement = document.createElement('div');
            messageElement.className = `log-message log-${level}`;
            messageElement.textContent = message;
            logElement.appendChild(messageElement);
        }
    });
    
    // Auto-scroll to bottom
    logElement.scrollTop = logElement.scrollHeight;
    
    console.log(`Log level set to: ${currentLogLevel}`);
}

/**
 * Initialize Bootstrap form validation
 */
function initializeFormValidation() {
    const forms = document.querySelectorAll('.needs-validation');
    Array.from(forms).forEach(form => {
        form.addEventListener('submit', event => {
            if (!form.checkValidity()) {
                event.preventDefault();
                event.stopPropagation();
            }
            form.classList.add('was-validated');
        }, false);
    });
}

/**
 * Initialize configuration-related event handlers
 */
function initializeConfigurationHandlers() {
    const configSelect = document.getElementById('config_name');
    const settingsSelect = document.getElementById('settings_name');
    
    if (configSelect) {
        configSelect.addEventListener('change', function () {
            if (this.value && currentStatsSource) {
                loadConfigurationYaml(currentStatsSource, this.value);
            }
        });
    }
    
    if (settingsSelect) {
        settingsSelect.addEventListener('change', function () {
            if (this.value) {
                loadSettingsYaml(this.value);
            }
        });
    }
}

/**
 * Check initial configuration state on page load
 */
function checkInitialConfigState() {
    const editConfigButton = document.getElementById('edit-config-btn');
    const editSettingsButton = document.getElementById('edit-settings-btn');
    const customConfigYaml = document.getElementById('config_yaml');
    const customSettingsYaml = document.getElementById('settings_yaml');
    
    if (editConfigButton && customConfigYaml && customConfigYaml.value && customConfigYaml.value.trim()) {
        editConfigButton.innerHTML = '<i class="bi bi-pencil-square me-1"></i> Customized';
        editConfigButton.classList.remove('btn-outline-secondary');
        editConfigButton.classList.add('btn-outline-warning');
    }
    
    if (editSettingsButton && customSettingsYaml && customSettingsYaml.value && customSettingsYaml.value.trim()) {
        editSettingsButton.innerHTML = '<i class="bi bi-pencil-square me-1"></i> Customized';
        editSettingsButton.classList.remove('btn-outline-secondary');
        editSettingsButton.classList.add('btn-outline-warning');
    }
}

/**
 * Load available settings and configurations for a selected statistics source
 * @param {string} statsSource - The selected statistics source identifier
 */
function loadSettingsAndConfigurations(statsSource) {
    const settingsSelect = document.getElementById('settings_name');
    const configSelect = document.getElementById('config_name');
    const editSettingsButton = document.getElementById('edit-settings-btn');
    const editConfigButton = document.getElementById('edit-config-btn');

    if (!statsSource) {
        resetSettingsAndConfigurationControls(settingsSelect, configSelect, editSettingsButton, editConfigButton);
        return;
    }

    currentStatsSource = statsSource;
    showSettingsAndConfigurationLoading(settingsSelect, configSelect, editSettingsButton, editConfigButton);

    // Load settings and configurations in parallel
    Promise.all([
        fetch('/experiment/settings').then(response => response.json()),
        fetch(`/experiment/configs/${statsSource}`).then(response => response.json())
    ])
    .then(([settingsData, configsData]) => {
        // Handle settings
        if (settingsData.error) {
            handleSettingsError(settingsSelect, settingsData.error);
        } else if (!settingsData.settings || settingsData.settings.length === 0) {
            showNoSettingsAvailable(settingsSelect);
        } else {
            populateSettingsOptions(settingsSelect, settingsData.settings);
            enableSettingsControls(settingsSelect, editSettingsButton);
            loadDefaultSettings(settingsSelect);
        }

        // Handle configurations
        if (configsData.error) {
            handleConfigurationError(configSelect, configsData.error);
        } else if (!configsData.configs || configsData.configs.length === 0) {
            showNoConfigurationsAvailable(configSelect);
        } else {
            populateConfigurationOptions(configSelect, configsData.configs);
            enableConfigurationControls(configSelect, editConfigButton);
            loadDefaultConfiguration(configSelect);
        }
    })
    .catch(error => {
        console.error('Error fetching settings and configurations:', error);
        handleSettingsError(settingsSelect, 'Error loading settings');
        handleConfigurationError(configSelect, 'Error loading configurations');
    });
}

/**
 * Reset settings and configuration controls to initial state
 */
function resetSettingsAndConfigurationControls(settingsSelect, configSelect, editSettingsButton, editConfigButton) {
    settingsSelect.disabled = true;
    configSelect.disabled = true;
    editSettingsButton.disabled = true;
    editConfigButton.disabled = true;
    settingsSelect.innerHTML = '<option value="" disabled selected>Select a statistics source first</option>';
    configSelect.innerHTML = '<option value="" disabled selected>Select a statistics source first</option>';
}

/**
 * Show loading state for settings and configuration controls
 */
function showSettingsAndConfigurationLoading(settingsSelect, configSelect, editSettingsButton, editConfigButton) {
    settingsSelect.disabled = true;
    configSelect.disabled = true;
    editSettingsButton.disabled = true;
    editConfigButton.disabled = true;
    settingsSelect.innerHTML = '<option value="" disabled selected>Loading settings...</option>';
    configSelect.innerHTML = '<option value="" disabled selected>Loading configurations...</option>';
}

/**
 * Handle settings loading errors
 */
function handleSettingsError(settingsSelect, errorMessage) {
    settingsSelect.innerHTML = '<option value="" disabled selected>Error loading settings</option>';
    console.error('Settings loading error:', errorMessage);
}

/**
 * Handle configuration loading errors
 */
function handleConfigurationError(configSelect, errorMessage) {
    configSelect.innerHTML = '<option value="" disabled selected>Error loading configurations</option>';
    console.error('Configuration loading error:', errorMessage);
}

/**
 * Show message when no settings are available
 */
function showNoSettingsAvailable(settingsSelect) {
    settingsSelect.innerHTML = '<option value="" disabled selected>No settings available</option>';
}

/**
 * Show message when no configurations are available
 */
function showNoConfigurationsAvailable(configSelect) {
    configSelect.innerHTML = '<option value="" disabled selected>No configurations available</option>';
}

/**
 * Populate settings select with available options
 */
function populateSettingsOptions(settingsSelect, settings) {
    settingsSelect.innerHTML = '<option value="" disabled selected>Select settings</option>';
    
    settings.forEach(([key, description]) => {
        const option = document.createElement('option');
        option.value = key;
        option.textContent = description;
        if (key === 'default') {
            option.selected = true;
        }
        settingsSelect.appendChild(option);
    });
}

/**
 * Populate configuration select with available options
 */
function populateConfigurationOptions(configSelect, configs) {
    configSelect.innerHTML = '<option value="" disabled selected>Select a configuration</option>';
    
    configs.forEach(([key, description]) => {
        const option = document.createElement('option');
        option.value = key;
        option.textContent = description;
        if (key === 'default') {
            option.selected = true;
        }
        configSelect.appendChild(option);
    });
}

/**
 * Enable settings controls after successful loading
 */
function enableSettingsControls(settingsSelect, editSettingsButton) {
    settingsSelect.disabled = false;
    editSettingsButton.disabled = false;
}

/**
 * Enable configuration controls after successful loading
 */
function enableConfigurationControls(configSelect, editConfigButton) {
    configSelect.disabled = false;
    editConfigButton.disabled = false;
}

/**
 * Load default settings if available
 */
function loadDefaultSettings(settingsSelect) {
    if (settingsSelect.value || settingsSelect.querySelector('option[value="default"]')) {
        const selectedSettings = settingsSelect.value || 'default';
        loadSettingsYaml(selectedSettings);
    }
}

/**
 * Load default configuration if available
 */
function loadDefaultConfiguration(configSelect) {
    if (configSelect.value || configSelect.querySelector('option[value="default"]')) {
        const selectedConfig = configSelect.value || 'default';
        loadConfigurationYaml(currentStatsSource, selectedConfig);
    }
}

/**
 * Load YAML settings content for editing
 * @param {string} settingsName - Settings name
 */
function loadSettingsYaml(settingsName) {
    fetch(`/experiment/settings/${settingsName}/yaml`)
        .then(response => response.json())
        .then(data => {
            if (data.error) {
                console.error('Error loading settings YAML:', data.error);
                return;
            }
            
            originalSettingsYaml = data.yaml;
            // Clear any custom YAML since we're loading a predefined setting
            document.getElementById('settings_yaml').value = '';

            // Reset edit button state
            resetEditSettingsButtonState();
        })
        .catch(error => {
            console.error('Error fetching settings YAML:', error);
        });
}

/**
 * Load YAML configuration content for editing
 * @param {string} statsSource - Statistics source identifier
 * @param {string} configName - Configuration name
 */
function loadConfigurationYaml(statsSource, configName) {
    fetch(`/experiment/configs/${statsSource}/${configName}/yaml`)
        .then(response => response.json())
        .then(data => {
            if (data.error) {
                console.error('Error loading config YAML:', data.error);
                return;
            }
            
            originalConfigYaml = data.yaml;
            // Clear any custom YAML since we're loading a predefined config
            document.getElementById('config_yaml').value = '';

            // Reset edit button state
            resetEditConfigButtonState();
        })
        .catch(error => {
            console.error('Error fetching config YAML:', error);
        });
}

/**
 * Reset edit settings button to default state
 */
function resetEditSettingsButtonState() {
    const editButton = document.getElementById('edit-settings-btn');
    editButton.innerHTML = '<i class="bi bi-pencil-square me-1"></i> Edit';
    editButton.classList.remove('btn-outline-success', 'btn-outline-warning');
    editButton.classList.add('btn-outline-secondary');
}

/**
 * Reset edit config button to default state
 */
function resetEditConfigButtonState() {
    const editButton = document.getElementById('edit-config-btn');
    editButton.innerHTML = '<i class="bi bi-pencil-square me-1"></i> Edit';
    editButton.classList.remove('btn-outline-success', 'btn-outline-warning');
    editButton.classList.add('btn-outline-secondary');
}

/**
 * Open the settings editor modal
 */
function openSettingsEditor() {
    const settingsSelect = document.getElementById('settings_name');
    const selectedSettings = settingsSelect.value;

    if (!selectedSettings) {
        alert('Please select settings first.');
        return;
    }

    // Update modal info
    updateSettingsModalInfo(selectedSettings);
    
    // Load appropriate YAML content
    loadSettingsYamlIntoEditor();
    
    // Show the modal
    const modal = new bootstrap.Modal(document.getElementById('settingsEditorModal'));
    modal.show();
}

/**
 * Open the configuration editor modal
 */
function openConfigEditor() {
    const configSelect = document.getElementById('config_name');
    const selectedConfig = configSelect.value;

    if (!selectedConfig || !currentStatsSource) {
        alert('Please select a configuration first.');
        return;
    }

    // Update modal info
    updateConfigModalInfo(selectedConfig);
    
    // Load appropriate YAML content
    loadConfigYamlIntoEditor();
    
    // Show the modal
    const modal = new bootstrap.Modal(document.getElementById('configEditorModal'));
    modal.show();
}

/**
 * Update settings modal information
 */
function updateSettingsModalInfo(selectedSettings) {
    document.getElementById('settings-name').textContent = selectedSettings;
}

/**
 * Update configuration modal information
 */
function updateConfigModalInfo(selectedConfig) {
    document.getElementById('config-source-name').textContent = currentStatsSource;
    document.getElementById('config-original-name').textContent = selectedConfig;
}

/**
 * Load settings YAML content into the editor
 */
function loadSettingsYamlIntoEditor() {
    const customYaml = document.getElementById('settings_yaml').value;
    
    if (customYaml && customYaml.trim()) {
        // Load the previously edited YAML
        document.getElementById('settings-yaml-editor').value = customYaml;
        updateSettingsStatus('Modified', 'badge bg-warning');
    } else {
        // Load the original YAML
        document.getElementById('settings-yaml-editor').value = originalSettingsYaml;
        updateSettingsStatus('Unchanged', 'badge bg-secondary');
    }
}

/**
 * Load config YAML content into the editor
 */
function loadConfigYamlIntoEditor() {
    const customYaml = document.getElementById('config_yaml').value;
    
    if (customYaml && customYaml.trim()) {
        // Load the previously edited YAML
        document.getElementById('config-yaml-editor').value = customYaml;
        updateConfigStatus('Modified', 'badge bg-warning');
    } else {
        // Load the original YAML
        document.getElementById('config-yaml-editor').value = originalConfigYaml;
        updateConfigStatus('Unchanged', 'badge bg-secondary');
    }
}

/**
 * Update settings status display
 */
function updateSettingsStatus(statusText, statusClass) {
    const statusElement = document.getElementById('settings-status');
    if (statusElement) {
        statusElement.textContent = statusText;
        statusElement.className = statusClass;
    }
}

/**
 * Update configuration status display
 */
function updateConfigStatus(statusText, statusClass) {
    const statusElement = document.getElementById('config-status');
    if (statusElement) {
        statusElement.textContent = statusText;
        statusElement.className = statusClass;
    }
}

/**
 * Reset settings to original state
 */
function resetSettings() {
    document.getElementById('settings-yaml-editor').value = originalSettingsYaml;
    updateSettingsStatus('Unchanged', 'badge bg-secondary');

    // Clear the hidden settings_yaml field
    document.getElementById('settings_yaml').value = '';
    resetEditSettingsButtonState();
}

/**
 * Reset configuration to original state
 */
function resetConfiguration() {
    document.getElementById('config-yaml-editor').value = originalConfigYaml;
    updateConfigStatus('Unchanged', 'badge bg-secondary');

    // Clear the hidden config_yaml field
    document.getElementById('config_yaml').value = '';
    resetEditConfigButtonState();
}

/**
 * Save settings changes
 */
function saveSettings() {
    const yamlContent = document.getElementById('settings-yaml-editor').value.trim();

    if (!yamlContent) {
        alert('Settings cannot be empty.');
        return;
    }

    // Basic YAML validation
    if (!validateYamlSettings(yamlContent)) {
        return;
    }

    // Check if settings were actually modified
    const isActuallyModified = yamlContent.trim() !== originalSettingsYaml.trim();

    // Store the edited YAML
    document.getElementById('settings_yaml').value = yamlContent;

    // Update UI based on modification status
    updateSettingsUI(isActuallyModified);

    // Close the modal
    const modal = bootstrap.Modal.getInstance(document.getElementById('settingsEditorModal'));
    modal.hide();
}

/**
 * Save configuration changes
 */
function saveConfiguration() {
    const yamlContent = document.getElementById('config-yaml-editor').value.trim();

    if (!yamlContent) {
        alert('Configuration cannot be empty.');
        return;
    }

    // Basic YAML validation
    if (!validateYamlConfiguration(yamlContent)) {
        return;
    }

    // Check if configuration was actually modified
    const isActuallyModified = yamlContent.trim() !== originalConfigYaml.trim();

    // Store the edited YAML
    document.getElementById('config_yaml').value = yamlContent;

    // Update UI based on modification status
    updateConfigurationUI(isActuallyModified);

    // Close the modal
    const modal = bootstrap.Modal.getInstance(document.getElementById('configEditorModal'));
    modal.hide();
}

/**
 * Validate YAML settings content
 */
function validateYamlSettings(yamlContent) {
    try {
        // Basic validation - check for required sections
        if (!yamlContent.includes('name:')) {
            throw new Error('Settings must include name field');
        }
        return true;
    } catch (error) {
        alert('Invalid YAML settings: ' + error.message);
        return false;
    }
}

/**
 * Validate YAML configuration content
 */
function validateYamlConfiguration(yamlContent) {
    try {
        // Basic validation - check for required sections
        if (!yamlContent.includes('name:')) {
            throw new Error('Configuration must include name field');
        }
        return true;
    } catch (error) {
        alert('Invalid YAML configuration: ' + error.message);
        return false;
    }
}

/**
 * Update settings UI based on modification status
 */
function updateSettingsUI(isModified) {
    const editButton = document.getElementById('edit-settings-btn');
    
    if (isModified) {
        updateSettingsStatus('Modified', 'badge bg-warning');
        editButton.innerHTML = '<i class="bi bi-pencil-square me-1"></i> Customized';
        editButton.classList.remove('btn-outline-secondary');
        editButton.classList.add('btn-outline-warning');
    } else {
        updateSettingsStatus('Unchanged', 'badge bg-secondary');
        document.getElementById('settings_yaml').value = '';
        resetEditSettingsButtonState();
    }
}

/**
 * Update configuration UI based on modification status
 */
function updateConfigurationUI(isModified) {
    const editButton = document.getElementById('edit-config-btn');
    
    if (isModified) {
        updateConfigStatus('Modified', 'badge bg-warning');
        editButton.innerHTML = '<i class="bi bi-pencil-square me-1"></i> Customized';
        editButton.classList.remove('btn-outline-secondary');
        editButton.classList.add('btn-outline-warning');
    } else {
        updateConfigStatus('Unchanged', 'badge bg-secondary');
        document.getElementById('config_yaml').value = '';
        resetEditConfigButtonState();
    }
}

/**
 * Clean up EventSource connection
 */
function cleanupEventSource() {
    if (eventSource) {
        eventSource.close();
        eventSource = null;
        console.log('EventSource connection cleaned up');
    }
}

/**
 * Handle page unload to clean up connections
 */
window.addEventListener('beforeunload', function() {
    cleanupEventSource();
}); 