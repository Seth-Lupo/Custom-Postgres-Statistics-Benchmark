"""
PostgreSQL Statistics Estimator - Background Tasks

This module handles background task execution for long-running operations
like experiment execution. It manages the experiment status tracking and
provides the background task implementation for experiment running.

Functions:
    run_experiment_background: Execute experiment in background thread

Global Variables:
    experiment_status: In-memory experiment status tracking

Author: Generated by Assistant
Created: 2024
"""

from datetime import datetime
from sqlmodel import Session

from ..database import SessionLocal
from ..experiment import ExperimentRunner, ExperimentError
from ..logging_config import web_logger, stats_source_logger

# Global experiment runner instance
experiment_runner = ExperimentRunner()

# In-memory storage for experiment status
# In production, this should be replaced with Redis or similar
experiment_status = {}


def run_experiment_background(experiment_id: int, stats_source: str, 
                            settings_name: str, settings_yaml: str,
                            config_name: str, config_yaml: str, query: str, iterations: int, 
                            dump_path: str, name: str) -> None:
    """
    Execute an experiment in the background.
    
    This function runs an experiment asynchronously and updates the global
    experiment_status dictionary with progress information. It handles all
    experiment execution phases and error management.
    
    Note: Statistics reset strategy and transaction handling are now read
    from the settings YAML configuration, not passed as parameters.
    
    Args:
        experiment_id: Unique experiment tracking ID
        stats_source: Statistics source identifier
        settings_name: Settings name (optional)
        settings_yaml: Custom YAML settings (optional)
        config_name: Configuration name (optional)
        config_yaml: Custom YAML configuration (optional)
        query: SQL query to execute
        iterations: Number of trial iterations
        dump_path: Path to database dump file
        name: Experiment name
    """
    # Get database session for experiment execution
    db: Session = SessionLocal()
    
    try:
        web_logger.info(f"Starting background execution for experiment {experiment_id}")
        
        # Ensure experiment exists in status tracking
        if experiment_id not in experiment_status:
            web_logger.error(f"Experiment {experiment_id} not found in status tracking")
            return
        
        # Create progress callback function
        def progress_callback(message: str, current: int, total: int):
            """
            Update experiment progress and log messages.
            
            This callback is called by the experiment runner to provide
            progress updates that are streamed to the frontend via SSE.
            
            Args:
                message: Progress message
                current: Current progress value  
                total: Total progress value
            """
            if experiment_id not in experiment_status:
                web_logger.warning(f"Experiment {experiment_id} not found during progress update")
                return
                
            progress_percent = int((current / total) * 100) if total > 0 else 0
            status = experiment_status[experiment_id]
            status["progress"] = current
            status["total"] = total
            
            # Add timestamped message for frontend display
            timestamped_message = f"[{datetime.utcnow().strftime('%H:%M:%S')}] {message}"
            status["messages"].append(timestamped_message)
            
            web_logger.debug(f"Experiment {experiment_id} progress: {progress_percent}% - {message}")
        
        # Create stats source log callback to capture stats source logger messages
        def stats_source_log_callback(log_level: str, message: str):
            """
            Capture stats source log messages and forward them to experiment status.
            
            Args:
                log_level: Log level (INFO, WARNING, ERROR, etc.)
                message: Log message from stats source
            """
            if experiment_id not in experiment_status:
                return
                
            # Add timestamped message for frontend display
            timestamped_message = f"[{datetime.utcnow().strftime('%H:%M:%S')}] {message}"
            experiment_status[experiment_id]["messages"].append(timestamped_message)
            
            web_logger.debug(f"Stats source log for experiment {experiment_id}: {message}")
        
        # Set up stats source logger stream callback
        if hasattr(stats_source_logger, 'stream_handler'):
            stats_source_logger.stream_handler.set_stream_callback(stats_source_log_callback)
            web_logger.debug(f"Set up stats source logger stream callback for experiment {experiment_id}")
        
        # Execute the experiment using the experiment runner
        web_logger.info(f"Running experiment {experiment_id} with parameters:")
        web_logger.info(f"  Stats source: {stats_source}")
        web_logger.info(f"  Settings: {settings_name or 'default'}")
        web_logger.info(f"  Config: {config_name or 'default'}")
        web_logger.info(f"  Iterations: {iterations}")
        
        experiment = experiment_runner.run_experiment(
            session=db,
            stats_source=stats_source,
            settings_name=settings_name,
            settings_yaml=settings_yaml,
            config_name=config_name,
            config_yaml=config_yaml,
            query=query,
            iterations=iterations,
            dump_path=dump_path,
            progress_callback=progress_callback,
            name=name
        )
        
        # Mark experiment as completed
        if experiment_id in experiment_status:
            experiment_status[experiment_id]["status"] = "completed"
            experiment_status[experiment_id]["experiment"] = experiment
        
        web_logger.info(f"Experiment {experiment_id} completed successfully")
        
    except ExperimentError as e:
        # Handle experiment-specific errors
        error_message = str(e)
        web_logger.error(f"Experiment {experiment_id} failed with ExperimentError: {error_message}")
        
        if experiment_id in experiment_status:
            experiment_status[experiment_id]["status"] = "error"
            experiment_status[experiment_id]["error"] = error_message
            
            # Add error message to experiment logs
            timestamped_error = f"[{datetime.utcnow().strftime('%H:%M:%S')}] ❌ Error: {error_message}"
            experiment_status[experiment_id]["messages"].append(timestamped_error)
        
    except Exception as e:
        # Handle unexpected errors
        import traceback
        tb = traceback.format_exc()
        error_message = f"An unexpected error occurred: {str(e)}"
        
        web_logger.error(f"Experiment {experiment_id} failed with unexpected error: {error_message}")
        web_logger.debug(f"Traceback for experiment {experiment_id}:\n{tb}")
        
        if experiment_id in experiment_status:
            experiment_status[experiment_id]["status"] = "error"
            experiment_status[experiment_id]["error"] = error_message
            
            # Add error message to experiment logs
            timestamped_error = f"[{datetime.utcnow().strftime('%H:%M:%S')}] ❌ Unexpected error: {error_message}"
            experiment_status[experiment_id]["messages"].append(timestamped_error)
        
    finally:
        # Clean up stats source logger stream callback
        if hasattr(stats_source_logger, 'stream_handler'):
            stats_source_logger.stream_handler.set_stream_callback(None)
            web_logger.debug(f"Cleaned up stats source logger stream callback for experiment {experiment_id}")
        
        # Always close the database session
        db.close()
        web_logger.debug(f"Database session closed for experiment {experiment_id}")


def get_experiment_status_dict(experiment_id: int) -> dict:
    """
    Get experiment status dictionary by ID.
    
    Args:
        experiment_id: Unique experiment tracking ID
        
    Returns:
        Experiment status dictionary or None if not found
    """
    return experiment_status.get(experiment_id)


def cleanup_experiment_status(experiment_id: int) -> bool:
    """
    Remove experiment status from tracking.
    
    This function can be used to clean up completed experiments
    from memory to prevent memory leaks.
    
    Args:
        experiment_id: Unique experiment tracking ID
        
    Returns:
        True if experiment was removed, False if not found
    """
    if experiment_id in experiment_status:
        del experiment_status[experiment_id]
        web_logger.debug(f"Cleaned up status for experiment {experiment_id}")
        return True
    return False


def get_active_experiments() -> list:
    """
    Get list of currently active (running) experiments.
    
    Returns:
        List of experiment IDs that are currently running
    """
    active_experiments = []
    for exp_id, status in experiment_status.items():
        if status["status"] == "running":
            active_experiments.append(exp_id)
    
    return active_experiments


def get_experiment_summary() -> dict:
    """
    Get summary statistics about experiment status tracking.
    
    Returns:
        Dictionary with experiment status counts
    """
    summary = {
        "total_experiments": len(experiment_status),
        "running": 0,
        "completed": 0,
        "error": 0
    }
    
    for status in experiment_status.values():
        status_key = status["status"]
        if status_key in summary:
            summary[status_key] += 1
    
    return summary


def create_experiment_status_entry(experiment_id: int, name: str, iterations: int) -> dict:
    """
    Create a new experiment status tracking entry.
    
    Args:
        experiment_id: Unique experiment tracking ID
        name: Experiment name
        iterations: Total number of iterations
        
    Returns:
        Created status dictionary
    """
    status = {
        "status": "running",
        "progress": 0,
        "total": iterations,
        "messages": [],
        "log_level": "info",
        "experiment": None,
        "name": name,
        "created_at": datetime.utcnow(),
        "error": None
    }
    
    experiment_status[experiment_id] = status
    web_logger.debug(f"Created status entry for experiment {experiment_id}: {name}")
    
    return status 