"""
PostgreSQL Statistics Estimator - Experiment Routes

This module contains FastAPI routes for experiment management and execution.
It provides endpoints for displaying the experiment page, handling experiment
form submissions, and managing experiment lifecycle.

Routes:
    GET /experiment - Display experiment setup page
    POST /experiment - Submit and start new experiment

Author: Generated by Assistant
Created: 2024
"""

import os
import time
from fastapi import APIRouter, Request, Form, Depends, BackgroundTasks
from fastapi.responses import HTMLResponse
from fastapi.templating import Jinja2Templates
from sqlmodel import select, Session
from datetime import datetime

from ..database import get_db, SessionLocal
from ..experiment import ExperimentRunner, ExperimentError
from ..logging_config import web_logger
from ..models import Experiment as ExperimentModel
from .background_tasks import run_experiment_background, experiment_status

# Initialize router and templates
router = APIRouter()
templates = Jinja2Templates(directory="app/templates")

# Global experiment runner instance
experiment_runner = ExperimentRunner()


@router.get("/experiment", response_class=HTMLResponse)
def experiment_page(request: Request):
    """
    Display the experiment setup page with available options.
    
    This endpoint renders the experiment configuration form with:
    - Available statistics sources
    - Available dump and query files
    - Form for experiment parameters
    
    Args:
        request: FastAPI request object for template rendering
        
    Returns:
        HTMLResponse with the experiment setup page
    """
    web_logger.info("Loading experiment page")
    
    # Get available statistics sources
    src = experiment_runner.get_available_src()
    
    # Get available dump and query files from upload directories
    uploads_dir = "app/uploads"
    dumps_dir = os.path.join(uploads_dir, "dumps")
    queries_dir = os.path.join(uploads_dir, "queries")
    
    # List available files with error handling
    try:
        dump_files = [f for f in os.listdir(dumps_dir) if f.endswith(('.sql', '.dump'))]
    except (FileNotFoundError, PermissionError):
        dump_files = []
        web_logger.warning(f"Could not access dumps directory: {dumps_dir}")
        
    try:
        query_files = [f for f in os.listdir(queries_dir) if f.endswith('.sql')]
    except (FileNotFoundError, PermissionError):
        query_files = []
        web_logger.warning(f"Could not access queries directory: {queries_dir}")
    
    # Check if queries are available
    queries_not_available = len(query_files) == 0
    
    web_logger.debug(f"Found {len(dump_files)} dump files and {len(query_files)} query files")
    
    return templates.TemplateResponse("experiment.html", {
        "request": request,
        "src": src,
        "dump_files": dump_files,
        "query_files": query_files,
        "queries_not_available": queries_not_available,
    })


@router.post("/experiment")
def submit_experiment(
    request: Request,
    background_tasks: BackgroundTasks,
    experiment_name: str = Form(...),
    stats_source: str = Form(...),
    settings_name: str = Form(None),
    settings_yaml: str = Form(None),
    config_name: str = Form(None),
    config_yaml: str = Form(None),
    iterations: int = Form(...),
    stats_reset_strategy: str = Form(...),
    transaction_handling: str = Form(...),
    dump_file: str = Form(...),
    query_file: str = Form(...),
    db: Session = Depends(get_db)
):
    """
    Submit and start a new experiment execution.
    
    This endpoint processes the experiment form submission, validates the
    parameters, checks for name conflicts, and launches the experiment
    in the background.
    
    Args:
        request: FastAPI request object
        background_tasks: FastAPI background tasks manager
        experiment_name: User-provided experiment name
        stats_source: Selected statistics source
        settings_name: Selected settings name (optional)
        settings_yaml: Custom YAML settings (optional)
        config_name: Selected configuration name (optional)
        config_yaml: Custom YAML configuration (optional)
        iterations: Number of trial iterations
        stats_reset_strategy: Statistics reset strategy ('once' or 'per_trial')
        transaction_handling: Transaction handling ('rollback' or 'persist')
        dump_file: Selected database dump file
        query_file: Selected query file
        db: Database session dependency
        
    Returns:
        HTMLResponse with experiment progress display or error message
    """
    try:
        # Log experiment submission details
        settings_display = f"settings '{settings_name}'" if settings_name else "default settings"
        config_display = f"config '{config_name}'" if config_name else "default config"
        web_logger.info(f"Starting experiment '{experiment_name}' with {stats_source} source ({settings_display}, {config_display}), {iterations} iterations")
        web_logger.info(f"Stats reset strategy: {stats_reset_strategy}, Transaction handling: {transaction_handling}")
        web_logger.info(f"Dump: {dump_file}, Query: {query_file}")
        
        if settings_yaml:
            web_logger.debug(f"Using custom settings: {settings_yaml[:200]}...")
        if config_yaml:
            web_logger.debug(f"Using custom configuration: {config_yaml[:200]}...")

        # Check for experiment name conflicts
        existing_experiment = _check_experiment_name_conflict(db, experiment_name)
        if existing_experiment:
            error_msg = f"An experiment with the name '{experiment_name}' has already been executed. Please choose a different name."
            web_logger.error(error_msg)
            return HTMLResponse(f"""
                <div class='alert alert-danger'>
                    <strong>Error:</strong> {error_msg}
                </div>
            """, status_code=400)

        # Validate and prepare file paths
        uploads_dir = "app/uploads"
        dump_path = os.path.join(uploads_dir, "dumps", dump_file)
        query_path = os.path.join(uploads_dir, "queries", query_file)
        
        # Validate files exist and are accessible
        file_validation_error = _validate_experiment_files(dump_path, query_path, dump_file, query_file)
        if file_validation_error:
            return file_validation_error

        # Read and validate query content
        query = _read_and_validate_query(query_path, query_file)
        if isinstance(query, HTMLResponse):  # Error response
            return query

        # Clean up old completed experiments (keep only running and recent completed ones)
        current_time = time.time()
        experiments_to_cleanup = []
        for exp_id, status in experiment_status.items():
            if (status["status"] in ["completed", "error"] and 
                "created_at" in status and 
                (current_time - status["created_at"].timestamp()) > 3600):  # 1 hour old
                experiments_to_cleanup.append(exp_id)
        
        for exp_id in experiments_to_cleanup:
            del experiment_status[exp_id]
            web_logger.debug(f"Cleaned up old experiment {exp_id}")

        # Create experiment status entry for tracking with unique timestamp-based ID
        experiment_id = int(time.time() * 1000)  # Use millisecond timestamp for uniqueness
        experiment_status[experiment_id] = {
            "status": "running",
            "progress": 0,
            "total": iterations,
            "messages": [],
            "log_level": "info",
            "experiment": None,
            "name": experiment_name,
            "created_at": datetime.utcnow()
        }
        
        web_logger.info(f"Created experiment tracking entry with ID {experiment_id}")
        
        # Launch experiment in background
        background_tasks.add_task(
            run_experiment_background, 
            experiment_id, stats_source, settings_name, settings_yaml,
            config_name, config_yaml, query, 
            iterations, stats_reset_strategy, transaction_handling, 
            dump_path, experiment_name
        )
        
        # Return progress display HTML
        return _generate_experiment_progress_html(
            experiment_id, experiment_name, iterations, stats_source, 
            stats_reset_strategy, transaction_handling, dump_file, query_file
        )
        
    except Exception as e:
        # Handle unexpected errors
        import traceback
        tb = traceback.format_exc()
        error_msg = f"Failed to start experiment: {str(e)}"
        web_logger.error(error_msg)
        web_logger.debug(tb)
        
        return HTMLResponse(f"""
            <div class='alert alert-danger'>
                <strong>Exception:</strong> {error_msg}<br>
                <pre>{tb}</pre>
            </div>
        """, status_code=500)


def _check_experiment_name_conflict(db: Session, experiment_name: str) -> bool:
    """
    Check if an experiment with the given name already exists and has been executed.
    
    Args:
        db: Database session
        experiment_name: Experiment name to check
        
    Returns:
        True if conflict exists, False otherwise
    """
    query = select(ExperimentModel).where(ExperimentModel.name == experiment_name)
    result = db.execute(query)
    existing_experiment = result.scalar_one_or_none()
    
    return existing_experiment and existing_experiment.is_executed


def _validate_experiment_files(dump_path: str, query_path: str, dump_file: str, query_file: str) -> HTMLResponse:
    """
    Validate that experiment files exist and are accessible.
    
    Args:
        dump_path: Full path to dump file
        query_path: Full path to query file
        dump_file: Dump filename for error messages
        query_file: Query filename for error messages
        
    Returns:
        HTMLResponse with error message if validation fails, None if success
    """
    # Validate dump file
    if not os.path.exists(dump_path):
        error_msg = f"Selected dump file not found: {dump_file}"
        web_logger.error(error_msg)
        return HTMLResponse(f"""
            <div class='alert alert-danger'>
                <strong>Error:</strong> {error_msg}<br>
                <pre>dump_path: {dump_path}</pre>
            </div>
        """, status_code=400)
        
    # Validate query file
    if not os.path.exists(query_path):
        error_msg = f"Selected query file not found: {query_file}"
        web_logger.error(error_msg)
        return HTMLResponse(f"""
            <div class='alert alert-danger'>
                <strong>Error:</strong> {error_msg}<br>
                <pre>query_path: {query_path}</pre>
            </div>
        """, status_code=400)
    
    return None


def _read_and_validate_query(query_path: str, query_file: str):
    """
    Read and validate query file content.
    
    Args:
        query_path: Path to query file
        query_file: Query filename for error messages
        
    Returns:
        Query string if successful, HTMLResponse if error
    """
    try:
        with open(query_path, "r") as f:
            queries_content = f.read()
        web_logger.debug("Successfully read queries file")
        
        # Parse queries (separated by semicolon)
        queries = [q.strip() for q in queries_content.split(';') if q.strip()]
        if not queries:
            error_msg = "No valid queries found in file"
            web_logger.error(error_msg)
            return HTMLResponse(f"""
                <div class='alert alert-danger'>
                    <strong>Error:</strong> {error_msg}<br>
                    <pre>query_file: {query_file}</pre>
                </div>
            """, status_code=400)
            
        # Use the first query for now
        query = queries[0]
        web_logger.debug(f"Using query: {query[:100]}...")  # Log first 100 chars
        return query
        
    except Exception as e:
        error_msg = f"Failed to read query file: {str(e)}"
        web_logger.error(error_msg)
        return HTMLResponse(f"""
            <div class='alert alert-danger'>
                <strong>Error:</strong> {error_msg}<br>
                <pre>query_file: {query_file}</pre>
            </div>
        """, status_code=400)


def _generate_experiment_progress_html(experiment_id: int, experiment_name: str, 
                                     iterations: int, stats_source: str,
                                     stats_reset_strategy: str, transaction_handling: str,
                                     dump_file: str, query_file: str) -> HTMLResponse:
    """
    Generate HTML for experiment progress display.
    
    Args:
        experiment_id: Unique experiment tracking ID
        experiment_name: User-provided experiment name
        iterations: Number of iterations
        stats_source: Statistics source name
        stats_reset_strategy: Statistics reset strategy
        transaction_handling: Transaction handling mode
        dump_file: Dump filename
        query_file: Query filename
        
    Returns:
        HTMLResponse with progress display
    """
    return HTMLResponse(f"""
    <style>
        .log-message {{
            margin: 2px 0;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', monospace;
            font-size: 0.9em;
            line-height: 1.2;
        }}
        .log-info {{
            color: #0d6efd;
            background-color: rgba(13, 110, 253, 0.1);
        }}
        .log-warning {{
            color: #f57c00;
            background-color: rgba(245, 124, 0, 0.1);
        }}
        .log-error {{
            color: #dc3545;
            background-color: rgba(220, 53, 69, 0.1);
            font-weight: 500;
        }}
        .progress-bar {{
            transition: width 0.3s ease;
        }}
        #progress-log-{experiment_id} {{
            white-space: pre-wrap;
            word-wrap: break-word;
            max-height: 300px;
            overflow-y: auto;
            padding: 12px;
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 0.375rem;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', monospace;
            font-size: 0.875rem;
            line-height: 1.4;
        }}
    </style>
    <div id="experiment-result">
        <div class="alert alert-info">
            <strong>Experiment Started!</strong> Running {iterations} iterations with {stats_source}...<br>
            <span class="text-muted">Name: {experiment_name} | Stats: {stats_reset_strategy} | Transaction: {transaction_handling}</span><br>
            <span class="text-muted">Dump: {dump_file} | Query: {query_file}</span>
        </div>
        <div class="progress mb-3">
            <div class="progress-bar progress-bar-striped progress-bar-animated" role="progressbar" 
                 style="width: 0%" id="progress-bar-{experiment_id}" 
                 aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">0%</div>
        </div>
        <div class="card">
            <div class="card-header d-flex justify-content-between align-items-center">
                <h5 class="mb-0">
                    <i class="bi bi-activity me-2"></i>
                    Experiment Progress
                </h5>
                <div class="btn-group btn-group-sm" role="group">
                    <button type="button" class="btn btn-outline-secondary active" onclick="setLogLevel('info', this)">
                        <i class="bi bi-info-circle me-1"></i>Info
                    </button>
                    <button type="button" class="btn btn-outline-warning" onclick="setLogLevel('warning', this)">
                        <i class="bi bi-exclamation-triangle me-1"></i>Warnings
                    </button>
                    <button type="button" class="btn btn-outline-danger" onclick="setLogLevel('error', this)">
                        <i class="bi bi-x-circle me-1"></i>Errors
                    </button>
                </div>
            </div>
            <div class="card-body p-0">
                <div id="progress-log-{experiment_id}"></div>
            </div>
        </div>
    </div>
    """) 