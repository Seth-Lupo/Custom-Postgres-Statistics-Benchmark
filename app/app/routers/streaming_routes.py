"""
PostgreSQL Statistics Estimator - Streaming Routes

This module contains FastAPI routes for Server-Sent Events (SSE) streaming
functionality. It provides real-time progress updates for experiment execution
using event streaming to the frontend.

Routes:
    GET /experiment/stream/{experiment_id} - SSE stream for experiment progress

Author: Generated by Assistant
Created: 2024
"""

import asyncio
import json
from fastapi import APIRouter
from fastapi.responses import StreamingResponse

from ..logging_config import web_logger
from .background_tasks import experiment_status

# Initialize router
router = APIRouter()


@router.get("/experiment/stream/{experiment_id}")
async def experiment_stream(experiment_id: int):
    """
    Stream experiment progress via Server-Sent Events (SSE).
    
    This endpoint provides real-time updates about experiment execution
    progress using SSE. It streams progress percentages, log messages,
    and completion status to the frontend.
    
    Args:
        experiment_id: Unique experiment tracking ID
        
    Returns:
        StreamingResponse with SSE event stream
        
    SSE Event Format:
        data: {"status": "running", "progress": 50, "messages": [...]}
        data: {"status": "completed", "html": "<div>...</div>"}
        data: {"status": "error", "error": "Error message"}
    """
    
    async def event_generator():
        """
        Async generator that yields SSE-formatted experiment progress events.
        
        This generator polls the experiment status and yields formatted
        SSE events containing progress updates, log messages, and status changes.
        """
        web_logger.debug(f"Starting SSE stream for experiment {experiment_id}")
        
        while True:
            # Check if experiment exists in tracking
            if experiment_id not in experiment_status:
                error_event = _create_error_event("Experiment not found")
                web_logger.warning(f"SSE stream requested for non-existent experiment {experiment_id}")
                yield error_event
                break
            
            status = experiment_status[experiment_id]
            
            # Handle running experiment
            if status["status"] == "running":
                event_data = _handle_running_experiment(status)
                if event_data:
                    yield event_data
                    
            # Handle completed experiment
            elif status["status"] == "completed":
                event_data = _handle_completed_experiment(status)
                web_logger.info(f"SSE stream completed for experiment {experiment_id}")
                yield event_data
                break
                
            # Handle failed experiment
            elif status["status"] == "error":
                event_data = _handle_error_experiment(status)
                web_logger.warning(f"SSE stream ended with error for experiment {experiment_id}")
                yield event_data
                break
            
            # Wait before next poll (200ms for responsive updates)
            await asyncio.sleep(0.2)
    
    return StreamingResponse(
        event_generator(), 
        media_type="text/event-stream",
        headers={
            "Cache-Control": "no-cache",
            "Connection": "keep-alive",
            "Access-Control-Allow-Origin": "*",
            "Access-Control-Allow-Headers": "Cache-Control"
        }
    )


def _handle_running_experiment(status: dict) -> str:
    """
    Handle progress updates for a running experiment.
    
    Args:
        status: Experiment status dictionary
        
    Returns:
        SSE-formatted event data string or None if no new messages
    """
    messages = status["messages"]
    
    # Only send events if there are new messages
    if not messages:
        return None
        
    # Calculate progress percentage
    progress_percent = int((status["progress"] / status["total"]) * 100) if status["total"] > 0 else 0
    
    # Determine log level from messages
    current_log_level = _determine_log_level(messages)
    
    # Create event data
    event_data = {
        "messages": messages,
        "progress": progress_percent,
        "status": "running",
        "log_level": current_log_level
    }
    
    # Clear processed messages
    status["messages"] = []
    
    return f"data: {json.dumps(event_data)}\n\n"


def _handle_completed_experiment(status: dict) -> str:
    """
    Handle completion event for a finished experiment.
    
    Args:
        status: Experiment status dictionary
        
    Returns:
        SSE-formatted completion event data string
    """
    experiment = status.get("experiment")
    exp_id = experiment.id if experiment else "unknown"
    
    event_data = {
        "status": "completed",
        "progress": 100,
        "log_level": "info",
        "html": f"""
            <div class="alert alert-success mb-3">
                <strong>Experiment Completed!</strong>
                <br>
                <a href="/results/{exp_id}" class="btn btn-primary mt-2">View Results</a>
            </div>
        """
    }
    
    return f"data: {json.dumps(event_data)}\n\n"


def _handle_error_experiment(status: dict) -> str:
    """
    Handle error event for a failed experiment.
    
    Args:
        status: Experiment status dictionary
        
    Returns:
        SSE-formatted error event data string
    """
    error_message = status.get("error", "Unknown error")
    
    event_data = {
        "status": "error",
        "progress": 100,
        "log_level": "error",
        "html": f"""
            <div class="alert alert-danger mb-3">
                <strong>Experiment Failed:</strong> {error_message}
            </div>
        """
    }
    
    return f"data: {json.dumps(event_data)}\n\n"


def _create_error_event(error_message: str) -> str:
    """
    Create an SSE error event.
    
    Args:
        error_message: Error message to include
        
    Returns:
        SSE-formatted error event string
    """
    event_data = {
        "error": error_message,
        "html": f"""
            <div class='alert alert-danger'>
                <strong>Error:</strong> {error_message}
            </div>
        """
    }
    
    return f"data: {json.dumps(event_data)}\n\n"


def _determine_log_level(messages: list) -> str:
    """
    Determine the appropriate log level based on message content.
    
    Args:
        messages: List of log messages
        
    Returns:
        Log level string ('error', 'warning', or 'info')
    """
    # Check for error indicators
    for msg in messages:
        if "❌" in msg or "ERROR" in msg.upper():
            return "error"
            
    # Check for warning indicators  
    for msg in messages:
        if "⚠️" in msg or "WARNING" in msg.upper():
            return "warning"
            
    # Default to info level
    return "info"


@router.get("/experiment/stream/{experiment_id}/status")
async def get_experiment_status(experiment_id: int):
    """
    Get current status of an experiment (non-streaming).
    
    This endpoint provides a one-time status check for an experiment
    without establishing a streaming connection. Useful for polling
    or status checks.
    
    Args:
        experiment_id: Unique experiment tracking ID
        
    Returns:
        JSONResponse with current experiment status
    """
    if experiment_id not in experiment_status:
        return {
            "error": "Experiment not found",
            "experiment_id": experiment_id
        }
    
    status = experiment_status[experiment_id]
    
    # Calculate progress percentage
    progress_percent = int((status["progress"] / status["total"]) * 100) if status["total"] > 0 else 0
    
    return {
        "experiment_id": experiment_id,
        "status": status["status"],
        "progress": progress_percent,
        "name": status.get("name", "Unknown"),
        "has_messages": len(status["messages"]) > 0,
        "message_count": len(status["messages"])
    }


@router.get("/experiment/debug/status")
async def debug_experiment_status():
    """
    Debug endpoint to see all current experiment statuses.
    
    Returns:
        JSONResponse with all experiment statuses for debugging
    """
    return {
        "experiments": experiment_status,
        "count": len(experiment_status),
        "experiment_ids": list(experiment_status.keys())
    } 